{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h2>AI Models Management</h2>
        <a href="/admin" class="btn btn-outline-secondary">Back to Admin</a>
    </div>

    <!-- Models Table -->
    <div class="card glass-panel mb-4">
        <div class="card-header d-flex justify-content-between align-items-center">
            <span>Configured Models</span>
            <!-- Add Model Button (Triggers Modal for simplicity or Redirect) -->
            <!-- We use a Modal for 'Add' which then redirects to Edit? Or just direct Add. -->
            <!-- Let's implement full Edit form in a Modal? No, dynamic form is big. -->
            <!-- We'll use a link to a separate page for consistency -->
            <!-- Wait, I haven't defined a GET /admin/models/new yet. -->
            <!-- I'll use a Modal to 'Start' (enter ref) then expand? -->
            <!-- Let's stick to 'Add' button opening a fresh form. -->
            <button class="btn btn-primary btn-sm add-model-btn" data-bs-toggle="modal"
                data-bs-target="#editModelModal">
                <i class="bi bi-plus-lg"></i> Add Model
            </button>
        </div>
        <div class="card-body p-0">
            <table class="table table-hover mb-0">
                <thead>
                    <tr>
                        <th>Display Name</th>
                        <th>Reference (Owner/Name)</th>
                        <th>Type</th>
                        <th>Status</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for m in models %}
                    <tr>
                        <td>{{ m.display_name }}</td>
                        <td><code>{{ m.model_ref }}</code></td>
                        <td><span class="badge bg-secondary">{{ m.type }}</span></td>
                        <td>
                            {% if m.is_active %}
                            <span class="badge bg-success">Active</span>
                            {% else %}
                            <span class="badge bg-secondary">Disabled</span>
                            {% endif %}
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-primary edit-model-btn" data-id="{{ m.id }}"
                                data-bs-toggle="modal" data-bs-target="#editModelModal">
                                Edit
                            </button>
                            <form action="/admin/models/delete" method="POST" class="d-inline"
                                onsubmit="return confirm('Delete model?');">
                                <input type="hidden" name="id" value="{{ m.id }}">
                                <button class="btn btn-sm btn-outline-danger">Del</button>
                            </form>
                        </td>
                    </tr>
                    {% else %}
                    <tr>
                        <td colspan="5" class="text-center text-muted">No models defined.</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
    // Serialize models for JS access
    const modelsData = {};
    {% for m in models %}
    modelsData["{{ m.id }}"] = {
        name: {{ m.display_name | tojson | safe }},
    ref: { { m.model_ref | tojson | safe } },
    type: { { m.type | tojson | safe } },
    active: { { m.is_active | tojson | safe } },
    schema: { { m.param_schema | tojson | safe } },
    defaults: { { m.default_params | tojson | safe } }
    };
    {% endfor %}

    // Event Delegation
    document.addEventListener('click', function (e) {
        // Edit Model
        if (e.target && e.target.classList.contains('edit-model-btn')) {
            const id = e.target.dataset.id;
            const m = modelsData[id];
            if (m) {
                openModelModal(id, m.name, m.ref, m.type, m.active, m.schema, m.defaults);
            }
        }
        // Add Model
        if (e.target && e.target.closest('.add-model-btn')) {
            openModelModal(); // Reset form
        }
    });

    let currentSchema = null;
    let currentDefaults = {};

    function openModelModal(id = null, name = '', ref = '', type = 'image', active = true, schema = null, defaults = null) {
        document.getElementById('modalTitle').textContent = id ? 'Edit Model' : 'Add AI Model';
        document.getElementById('modelId').value = id || '';
        document.getElementById('displayName').value = name;
        document.getElementById('modelRef').value = ref;
        document.getElementById('modelType').value = type;
        document.getElementById('modelActive').checked = active;

        currentSchema = schema;
        currentDefaults = defaults || {};

        renderSchema();

        // Show modal if not already triggered by data-bs-target (which handles show, but we need data populated first)
        // Actually data-bs-toggle handles show. We just need to populate.
        // But if we populate AFTER show, user sees update.
        // It's fine.
    }

    document.getElementById('btnFetchSchema').addEventListener('click', async () => {
        const ref = document.getElementById('modelRef').value.trim();
        if (!ref) return alert("Enter model reference first");

        const loader = document.getElementById('loadingSchema');
        const container = document.getElementById('schemaContainer');

        loader.classList.remove('d-none');
        container.innerHTML = '';

        try {
            const res = await fetch('/admin/models/resolve-schema', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ replicate_model_ref: ref })
            });
            const data = await res.json();

            if (data.ok) {
                currentSchema = data.schema;
                // Reset defaults if fetching new schema
                currentDefaults = {};
                renderSchema();
            } else {
                alert("Error: " + data.message);
            }
        } catch (e) {
            alert("Fetch failed: " + e.message);
        } finally {
            loader.classList.add('d-none');
        }
    });

    function renderSchema() {
        const container = document.getElementById('schemaContainer');
        if (!currentSchema || !currentSchema.fields) {
            container.innerHTML = '<p class="text-muted small">No schema loaded.</p>';
            document.getElementById('btnTestRun').disabled = true;
            return;
        }

        document.getElementById('btnTestRun').disabled = false;
        let html = '<div class="row">';

        currentSchema.fields.forEach(f => {
            // Skip hidden/system fields if needed
            if (f.name === 'seed') return; // Skip seed usually

            const val = currentDefaults[f.name] !== undefined ? currentDefaults[f.name] : (f.default || '');

            let inputHtml = '';
            const safeName = `param_${f.name}`;

            if (f.type === 'select') {
                let opts = f.choices.map(c => `<option value="${c.value}" ${c.value == val ? 'selected' : ''}>${c.label}</option>`).join('');
                inputHtml = `<select class="form-select form-select-sm param-input" data-name="${f.name}">${opts}</select>`;
            } else if (f.type === 'boolean') {
                inputHtml = `
             <div class="form-check form-switch">
                <input class="form-check-input param-input" type="checkbox" data-name="${f.name}" ${val ? 'checked' : ''}>
             </div>`;
            } else if (f.type === 'integer' || f.type === 'number') {
                inputHtml = `<input type="number" class="form-control form-control-sm param-input" data-name="${f.name}" value="${val}" step="${f.type === 'number' ? '0.01' : '1'}">`;
            } else {
                inputHtml = `<input type="text" class="form-control form-control-sm param-input" data-name="${f.name}" value="${val}">`;
            }

            html += `
        <div class="col-md-6 mb-2">
            <label class="form-label small mb-0" title="${f.help || ''}">${f.label}</label>
            ${inputHtml}
        </div>`;
        });

        html += '</div>';
        container.innerHTML = html;
    }

    function prepareSave() {
        // Collect params
        const defaults = {};
        document.querySelectorAll('.param-input').forEach(el => {
            const name = el.dataset.name;
            let val;
            if (el.type === 'checkbox') val = el.checked;
            else if (el.type === 'number') val = parseFloat(el.value);
            else val = el.value;

            defaults[name] = val;
        });

        document.getElementById('paramSchemaJson').value = JSON.stringify(currentSchema);
        document.getElementById('defaultParamsJson').value = JSON.stringify(defaults);
    }

    document.getElementById('btnTestRun').addEventListener('click', async () => {
        const btn = document.getElementById('btnTestRun');
        const resDiv = document.getElementById('testResult');

        // Collect current params as overrides
        prepareSave(); // Populate defaults map
        const params = JSON.parse(document.getElementById('defaultParamsJson').value);

        // We need to pass ModelRef too (if new) or ID (if edit). 
        // If ID is empty (Add Mode), we can't use GET /:id/test easily unless we pass EVERYTHING.
        // The router /:id/test expects saved model.
        // For "Add Mode", we should probably separate test endpoint or just save first?
        // User Requirement: "Save & Test".
        // I will disable Test for Unsaved models for MVP to keep it simple, 
        // OR create a generic /test-ephemeral endpoint.

        const id = document.getElementById('modelId').value;
        if (!id) {
            alert("Please Save the model first to test it.");
            return;
        }

        btn.disabled = true;
        resDiv.classList.remove('d-none');
        resDiv.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Submitting...';

        try {
            const res = await fetch(`/admin/models/${id}/test`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ params: params })
            });
            const data = await res.json();
            if (data.ok) {
                resDiv.innerHTML = `<div class="text-success">Job Submitted: <b>${data.job_id}</b></div><div class="small">Check Replicate dashboard.</div>`;
            } else {
                resDiv.innerHTML = `<div class="text-danger">Error: ${data.message}</div>`;
            }
        } catch (e) {
            resDiv.innerHTML = `<div class="text-danger">Error: ${e.message}</div>`;
        } finally {
            btn.disabled = false;
        }
    });

</script>
{% endblock %}