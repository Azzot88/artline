from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, or_, and_
from sqlalchemy.orm import joinedload
from app.domain.jobs.models import Job
from app.domain.users.models import User
from app.domain.providers.models import AIModel
from app.domain.billing.service import get_user_balance, add_ledger_entry
from app.domain.pricing.service import PricingService
from app.schemas import UserContext, UserRead
import uuid
import math
import logging

logger = logging.getLogger(__name__)

import json

async def create_job(
    db: AsyncSession, 
    user: User | object, # GuestProfile
    kind: str, 
    prompt: str, 
    model: str = "flux",
    params: dict = None
) -> tuple[Job | None, str | None]:
    
    # Determine if user or guest
    is_guest = not isinstance(user, User)
    
    # Resolve Model Object first (needed for PricingService)
    # The 'model' arg is currently a string ID or name. We need the object.
    model_obj = None
    try:
        model_uuid = uuid.UUID(model)
        stmt = select(AIModel).where(AIModel.id == model_uuid)
        res = await db.execute(stmt)
        model_obj = res.scalar_one_or_none()
    except ValueError:
        pass
        
    if not model_obj:
        # Fallback or Error? 
        # For refactor safety, let's error if strictly required, OR create a dummy/lookup if using legacy strings?
        # Current system passes "flux-pro" sometimes?
        # Let's try to find by reference or name if UUID fails
        # But PricingService needs an AIModel object. 
        # Ideally, we should fetch it.
        # If not found, we cannot quote accurately. 
        # Emergency Fallback: Create detailed error
        return None, "Model not found"

    # Construct UserContext for Pricing
    u_ctx = UserContext(
        is_guest=is_guest, 
        balance=user.balance,  # Guest has balance too
        user=UserRead.model_validate(user) if not is_guest else None,
        guest_id=str(user.id) if is_guest else None
    )

    # Get Quote
    quote = await PricingService.quote(db, model_obj, params or {}, u_ctx)
    cost = quote.total_credits
    
    # Check balance
    if is_guest:
        balance = user.balance
    else:
        balance = await get_user_balance(db, user.id)
        
    if balance < cost:
        return None, "Insufficient credits"

    # Deduct credits
    if is_guest:
        user.balance -= cost
        # Guest ledger not strictly required, balance field is source of truth
    else:
        await add_ledger_entry(
            db, 
            user.id, 
            -cost, 
            reason=f"job_cost:{model}", 
            external_id=None
        )

    # Create Job
    job = Job(
        kind=kind,
        cost_credits=cost,
        quote_id=quote.id, # Link Quote
        status="queued",
        progress=0,
        owner_type="guest" if is_guest else "user",
        is_public=False, # Default to PRIVATE per new logic (Library only)
        model_id=model_obj.id,
        provider=model_obj.provider # Derive from model
    )
    
    if is_guest:
        job.guest_id = user.id
        from datetime import datetime, timedelta
        # Set expiry for guest jobs
        job.expires_at = datetime.utcnow() + timedelta(days=15)
    else:
        job.user_id = user.id
    
    # Serialize structure: [model_id] <json> | prompt
    # If params exist, dump them.
    params_str = ""
    if params:
        try:
            params_str = json.dumps(params or {})
            
            # Extract metadata for columns
            ar = params.get("aspect_ratio", "1:1")
            
            # Map common ARs to format enum
            if ar in ["9:16", "9:21", "2:3", "3:4", "4:5"]:
                job.format = "portrait"
            elif ar in ["16:9", "21:9", "3:2", "4:3", "5:4"]:
                job.format = "landscape"
            else:
                job.format = "square"
                
            # Resolution (if available)
            if "width" in params and "height" in params:
                 # This is rare for Flux/Replicate inputs which use AR, but good to have
                 pass
            
            # Megapixels via 'megapixels'? Flux uses '1' or '0.25' sometimes
            # Just default to 1080 for now unless we see explicit data
            
        except:
             pass
    
    if params_str:
        job.prompt = f"[{model}] {params_str} | {prompt}"
    else:
        job.prompt = f"[{model}] {prompt}"
    
    db.add(job)
    
    # Link Job ID to Quote (Circular update)
    # quote.job_id = job.id # Can't do this yet as job.id might be None (it has default generator though)
    # Let's trust job.id is generated or flush first?
    # job.id is generated by Python or DB? Look at model: default=lambda: str(uuid.uuid4())
    # So job.id is set on init.
    quote.job_id = job.id
    
    await db.commit()
    await db.refresh(job)
    
    return job, None

async def get_user_jobs(db: AsyncSession, user: User | object, limit: int = 50):
    # Determine if guest
    is_guest = not isinstance(user, User)

    stmt = select(Job).options(joinedload(Job.model)).order_by(Job.created_at.desc()).limit(limit)
    
    if is_guest:
        stmt = stmt.where(Job.guest_id == user.id)
    else:
        stmt = stmt.where(Job.user_id == user.id)
        
    # Strict Availability Filter
    # Show only:
    # 1. Active jobs (queued, running)
    # 2. Succeeded jobs WITH a result_url (or failed if recently failed, but let's hide failed for now if desired)
    # Hide: deleted
    
    stmt = stmt.where(
        or_(
            Job.status.in_(['queued', 'running', 'failed']), # Show failed too so user knows
            and_(
                Job.status == 'succeeded',
                Job.result_url.isnot(None),
                Job.result_url != ''
            )
        )
    )
    stmt = stmt.where(Job.status != 'deleted')
        
    result = await db.execute(stmt)
    return result.scalars().all()

async def get_job_with_permission(db: AsyncSession, job_id: str, user: User | object):
    """
    Fetch job ensuring the user owns it. 
    """
    is_guest = not isinstance(user, User)
    stmt = select(Job).where(Job.id == job_id)
    
    if is_guest:
        stmt = stmt.where(Job.guest_id == user.id)
    else:
        stmt = stmt.where(Job.user_id == user.id)
        
    result = await db.execute(stmt)
    return result.scalar_one_or_none()

async def delete_job(db: AsyncSession, job_id: str, user: User | object) -> bool:
    """
    Soft delete a job if owned by user.
    """
    job = await get_job_with_permission(db, job_id, user)
    if not job:
        return False
        
    # Soft Delete
    job.status = 'deleted'
    job.is_public = False
    job.is_curated = False
    job.prompt = '[Deleted]'
    job.result_url = None
    job.thumbnailUrl = None
    job.input_image_url = None
    
    await db.commit()
    return True

async def like_job(db: AsyncSession, job_id: str) -> int:
    """
    Atomic like increment.
    """
    stmt = (
        update(Job)
        .where(Job.id == job_id)
        .values(likes=Job.likes + 1)
        .returning(Job.likes)
    )
    result = await db.execute(stmt)
    await db.commit()
    return result.scalar_one()

async def get_job(db: AsyncSession, job_id: str, user_id: uuid.UUID):
    result = await db.execute(
        select(Job).where(Job.id == job_id, Job.user_id == user_id)
    )
    return result.scalar_one_or_none()

async def get_curated_jobs(db: AsyncSession, limit: int = 6):
    stmt = (
        select(Job)
        .options(joinedload(Job.model))
        .where(Job.is_curated == True)
        .where(Job.status == 'succeeded')
        .where(Job.result_url.isnot(None))
        .order_by(Job.likes.desc())
        .limit(limit)
    )
    result = await db.execute(stmt)
    return result.scalars().all()

async def get_public_jobs(db: AsyncSession, limit: int = 50, offset: int = 0):
    stmt = (
        select(Job)
        .options(joinedload(Job.model))
        # .where(Job.is_curated == True) # RELAXED: Show all public jobs for now
        .where(Job.is_public == True)
        .where(Job.status == 'succeeded') 
        .where(Job.result_url.isnot(None))
        .order_by(Job.created_at.desc())
        .limit(limit)
        .offset(offset)
    )
    result = await db.execute(stmt)
    return result.scalars().all()

async def get_review_jobs(db: AsyncSession, limit: int = 50, offset: int = 0):
    """
    Fetch jobs that are submitted for review (is_public=True) 
    but NOT yet curated (is_curated=False).
    """
    stmt = (
        select(Job)
        .options(joinedload(Job.model))
        .where(Job.is_public == True)
        .where(Job.is_curated == False)
        .where(Job.status == 'succeeded') 
        .where(Job.result_url.isnot(None))
        .order_by(Job.created_at.asc()) # Oldest first for review queue
        .limit(limit)
        .offset(offset)
    )
    result = await db.execute(stmt)
    return result.scalars().all()

